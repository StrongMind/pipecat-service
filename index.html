<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pipecat Voice Bot Client</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }
        .controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 30px;
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        label {
            font-weight: 600;
            min-width: 100px;
        }
        select, input {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        }
        button {
            padding: 12px 24px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.2s;
        }
        .btn-primary {
            background: #007bff;
            color: white;
        }
        .btn-primary:hover {
            background: #0056b3;
        }
        .btn-danger {
            background: #dc3545;
            color: white;
        }
        .btn-danger:hover {
            background: #c82333;
        }
        .btn-secondary {
            background: #6c757d;
            color: white;
        }
        .btn-secondary:hover {
            background: #545b62;
        }
        .status {
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            font-weight: 600;
        }
        .status.connected {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .status.disconnected {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .status.connecting {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }
        .device-controls {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        .logs {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 15px;
            max-height: 300px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
            margin-top: 20px;
        }
        .error {
            color: #dc3545;
            background: #f8d7da;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }
        .mic-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 10px;
        }
        .mic-status {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #dc3545;
            transition: all 0.2s;
        }
        .mic-status.active {
            background: #28a745;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸŽ¤ Pipecat Voice Bot Client</h1>
        
        <div class="controls">
            <div class="control-group">
                <label for="serverUrl">Server URL:</label>
                <input type="text" id="serverUrl" value="http://localhost:8080" placeholder="http://localhost:8080">
            </div>
            
            <div class="control-group">
                <label for="botType">Bot Type:</label>
                <select id="botType">
                    <option value="nova">Nova</option>
                    <option value="openai">OpenAI</option>
                    <option value="gemini">Gemini</option>
                    <option value="polly">Polly</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="enableMic">Enable Microphone:</label>
                <input type="checkbox" id="enableMic" checked>
            </div>
        </div>
        
        <div class="device-controls">
            <button id="connectBtn" class="btn-primary">Connect to Bot</button>
            <button id="disconnectBtn" class="btn-danger" disabled>Disconnect</button>
            <button id="toggleMic" class="btn-secondary" disabled>Toggle Mic</button>
            <button id="debugAudio" class="btn-secondary" disabled>Debug Audio</button>
            <button id="testSpeakers" class="btn-secondary">Test Speakers</button>
        </div>
        
        <div id="status" class="status disconnected">Disconnected</div>
        
        <div class="mic-indicator">
            <div id="micStatus" class="mic-status"></div>
            <span id="micText">Microphone: Off</span>
        </div>
        
        <div id="error" class="error" style="display: none;"></div>
        
        <!-- Hidden audio element for output -->
        <audio id="botAudio" autoplay playsinline style="display: none;"></audio>
        
        <div id="logs" class="logs"></div>
    </div>

    <!-- Load the Pipecat JavaScript SDK using Skypack CDN -->
    <script type="module">
         import { PipecatClient } from "https://cdn.skypack.dev/@pipecat-ai/client-js";
         import { DailyTransport } from "https://cdn.skypack.dev/@pipecat-ai/daily-transport";
         
         class PipecatBotClient {
            constructor() {
                this.client = null;
                this.isConnected = false;
                this.initializeElements();
                this.setupEventListeners();
                this.updateMicStatus(false);
            }
            
            initializeElements() {
                this.serverUrlInput = document.getElementById('serverUrl');
                this.botTypeSelect = document.getElementById('botType');
                this.enableMicCheck = document.getElementById('enableMic');
                this.connectBtn = document.getElementById('connectBtn');
                this.disconnectBtn = document.getElementById('disconnectBtn');
                this.toggleMicBtn = document.getElementById('toggleMic');
                this.debugAudioBtn = document.getElementById('debugAudio');
                this.testSpeakersBtn = document.getElementById('testSpeakers');
                this.statusDiv = document.getElementById('status');
                this.errorDiv = document.getElementById('error');
                this.logsDiv = document.getElementById('logs');
                this.micStatus = document.getElementById('micStatus');
                this.micText = document.getElementById('micText');
            }
            
            setupEventListeners() {
                this.connectBtn.addEventListener('click', () => this.connect());
                this.disconnectBtn.addEventListener('click', () => this.disconnect());
                this.toggleMicBtn.addEventListener('click', () => this.toggleMicrophone());
                this.debugAudioBtn.addEventListener('click', () => this.debugAudioSetup());
                this.testSpeakersBtn.addEventListener('click', () => this.testSpeakers());
            }
            
            log(message) {
                const timestamp = new Date().toLocaleTimeString();
                this.logsDiv.innerHTML += `[${timestamp}] ${message}<br>`;
                this.logsDiv.scrollTop = this.logsDiv.scrollHeight;
            }
            
            updateMicStatus(isActive) {
                if (isActive) {
                    this.micStatus.classList.add('active');
                    this.micText.textContent = 'Microphone: Active';
                } else {
                    this.micStatus.classList.remove('active');
                    this.micText.textContent = 'Microphone: Off';
                }
            }
            
            debugAudioSetup() {
                if (this.client) {
                    try {
                        // Check available speakers
                        this.client.getAllSpeakers().then(speakers => {
                            this.log(`Available speakers: ${speakers.length}`);
                            speakers.forEach((speaker, i) => {
                                this.log(`  Speaker ${i}: ${speaker.label || speaker.deviceId}`);
                            });
                            
                            const selectedSpeaker = this.client.selectedSpeaker;
                            this.log(`Selected speaker: ${selectedSpeaker ? selectedSpeaker.label || selectedSpeaker.deviceId : 'none'}`);
                        }).catch(err => {
                            this.log(`Error getting speakers: ${err.message}`);
                        });

                        // Check audio tracks
                        const tracks = this.client.tracks();
                        this.log(`Active tracks: ${Object.keys(tracks).length}`);
                        Object.entries(tracks).forEach(([participantId, participantTracks]) => {
                            this.log(`  Participant ${participantId}:`);
                            if (participantTracks.audio) {
                                const audioTrack = participantTracks.audio;
                                this.log(`    Audio track: ${audioTrack.enabled ? 'enabled' : 'disabled'}`);
                                this.log(`    Audio track muted: ${audioTrack.muted || false}`);
                                this.log(`    Audio track readyState: ${audioTrack.readyState || 'unknown'}`);
                                
                                // Check if this is the bot's audio track
                                if (participantId === 'bot' || participantId.includes('bot')) {
                                    this.log(`    ðŸ”Š This is the bot's audio track`);
                                    this.testBotAudioTrack(audioTrack);
                                }
                            }
                        });

                        // Check browser audio context
                        if (typeof AudioContext !== 'undefined' || typeof webkitAudioContext !== 'undefined') {
                            this.log('Browser supports Web Audio API');
                        } else {
                            this.log('âš ï¸ Browser does not support Web Audio API');
                        }

                        // Test audio context and autoplay policy
                        this.testAudioPlayback();

                        // Check for autoplay policy
                        this.log('ðŸ’¡ If you don\'t hear audio, check:');
                        this.log('  - Browser autoplay policy (click anywhere to enable audio)');
                        this.log('  - System volume levels');
                        this.log('  - Browser tab is not muted');
                        this.log('  - Speaker device is working');
                    } catch (error) {
                        this.log(`Debug audio setup error: ${error.message}`);
                    }
                }
            }
            
            testAudioPlayback() {
                try {
                    const AudioContextClass = window.AudioContext || window.webkitAudioContext;
                    if (AudioContextClass) {
                        const audioContext = new AudioContextClass();
                        this.log(`Audio context state: ${audioContext.state}`);
                        
                        if (audioContext.state === 'suspended') {
                            this.log('âš ï¸ Audio context is suspended - user interaction needed');
                            audioContext.resume().then(() => {
                                this.log('âœ… Audio context resumed');
                            }).catch(err => {
                                this.log(`âŒ Failed to resume audio context: ${err.message}`);
                            });
                        } else {
                            this.log('âœ… Audio context is ready');
                        }
                    }
                } catch (error) {
                    this.log(`Audio test error: ${error.message}`);
                }
            }
            
            testBotAudioTrack(audioTrack) {
                try {
                    // Debug what properties/methods are available on the audio track
                    this.log(`    ðŸ” Audio track type: ${typeof audioTrack}`);
                    this.log(`    ðŸ” Audio track constructor: ${audioTrack.constructor?.name || 'unknown'}`);
                    
                    // List available methods
                    const methods = Object.getOwnPropertyNames(Object.getPrototypeOf(audioTrack))
                        .filter(name => typeof audioTrack[name] === 'function');
                    this.log(`    ðŸ“‹ Available methods: ${methods.slice(0, 10).join(', ')}${methods.length > 10 ? '...' : ''}`);
                    
                    // Try different ways to get MediaStream
                    let stream = null;
                    
                    // Method 1: getMediaStream
                    if (audioTrack.getMediaStream) {
                        stream = audioTrack.getMediaStream();
                        this.log(`    ðŸ”§ getMediaStream(): ${stream ? 'found' : 'null'}`);
                    } else {
                        this.log(`    âŒ getMediaStream() method not available`);
                    }
                    
                    // Method 2: track property
                    if (!stream && audioTrack.track) {
                        this.log(`    ðŸ”§ Trying audioTrack.track...`);
                        if (audioTrack.track.getSettings) {
                            this.log(`    ðŸ”§ audioTrack.track is MediaStreamTrack`);
                            // Create MediaStream from track
                            stream = new MediaStream([audioTrack.track]);
                            this.log(`    ðŸ”§ Created MediaStream from track: ${stream ? 'success' : 'failed'}`);
                        }
                    }
                    
                    // Method 3: _track property (Daily.js internal)
                    if (!stream && audioTrack._track) {
                        this.log(`    ðŸ”§ Trying audioTrack._track...`);
                        stream = new MediaStream([audioTrack._track]);
                        this.log(`    ðŸ”§ Created MediaStream from _track: ${stream ? 'success' : 'failed'}`);
                    }
                    
                    // Method 4: Access Daily transport directly
                    if (!stream && this.client && this.client.transport && this.client.transport.dailyCallClient) {
                        this.log(`    ðŸ”§ Trying Daily.js call object...`);
                        const participants = this.client.transport.dailyCallClient.participants();
                        this.log(`    ðŸ‘¥ Daily participants: ${Object.keys(participants).length}`);
                        
                        for (const [id, participant] of Object.entries(participants)) {
                            if (id !== 'local' && participant.audioTrack) {
                                this.log(`    ðŸŽ¤ Found Daily audio track for ${id}`);
                                stream = new MediaStream([participant.audioTrack]);
                                this.log(`    ðŸ”§ Created MediaStream from Daily track: ${stream ? 'success' : 'failed'}`);
                                break;
                            }
                        }
                    }
                    
                    if (stream) {
                        this.log(`    âœ… Bot audio MediaStream found!`);
                        this.log(`    Stream tracks: ${stream.getTracks().length}`);
                        stream.getTracks().forEach((track, i) => {
                            this.log(`      Track ${i}: kind=${track.kind}, enabled=${track.enabled}, readyState=${track.readyState}`);
                        });
                        
                        // Try to manually route audio to an audio element
                        const audioElement = document.getElementById('botAudio');
                        if (audioElement) {
                            audioElement.srcObject = stream;
                            audioElement.volume = 1.0;
                            this.log(`    ðŸ”§ Manually routed bot audio to audio element`);
                            this.log(`    Audio element volume: ${audioElement.volume}`);
                            this.log(`    Audio element muted: ${audioElement.muted}`);
                            
                            // Try to play
                            audioElement.play().then(() => {
                                this.log(`    âœ… Audio element play() succeeded`);
                                // Check if audio is actually playing
                                setTimeout(() => {
                                    this.checkAudioElementPlayback(audioElement);
                                }, 1000);
                            }).catch(err => {
                                this.log(`    âŒ Audio element play() failed: ${err.message}`);
                            });
                        }
                        
                        // Analyze the audio stream with Web Audio API
                        this.analyzeAudioStream(stream);
                    } else {
                        this.log(`    âŒ No MediaStream found through any method`);
                    }
                    
                    // Check track settings
                    const settings = audioTrack.getSettings ? audioTrack.getSettings() : {};
                    this.log(`    Track settings: volume=${settings.volume || 'unknown'}, sampleRate=${settings.sampleRate || 'unknown'}`);
                    
                } catch (error) {
                    this.log(`    Bot audio track test error: ${error.message}`);
                }
            }
            
            testSpeakers() {
                this.log('ðŸ”Š Testing speakers with tone...');
                try {
                    const AudioContextClass = window.AudioContext || window.webkitAudioContext;
                    const audioContext = new AudioContextClass();
                    
                    // Create a simple 440Hz tone for 1 second
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(440, audioContext.currentTime); // 440 Hz = A note
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime); // Low volume
                    
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 1); // Play for 1 second
                    
                    this.log('ðŸŽµ Playing 440Hz test tone for 1 second...');
                    this.log('ðŸ’¡ If you hear the tone, your speakers are working!');
                    
                    setTimeout(() => {
                        this.log('ðŸ”‡ Test tone finished');
                    }, 1100);
                    
                } catch (error) {
                    this.log(`âŒ Speaker test failed: ${error.message}`);
                }
            }
            
            checkAudioElementPlayback(audioElement) {
                try {
                    this.log(`    ðŸ” Audio element playback check:`);
                    this.log(`      - paused: ${audioElement.paused}`);
                    this.log(`      - currentTime: ${audioElement.currentTime}`);
                    this.log(`      - duration: ${audioElement.duration}`);
                    this.log(`      - volume: ${audioElement.volume}`);
                    this.log(`      - muted: ${audioElement.muted}`);
                    this.log(`      - srcObject: ${audioElement.srcObject ? 'set' : 'null'}`);
                    this.log(`      - readyState: ${audioElement.readyState}`);
                    
                    if (audioElement.paused) {
                        this.log(`    âš ï¸ Audio element is paused - trying to play again`);
                        audioElement.play().catch(err => {
                            this.log(`    âŒ Retry play failed: ${err.message}`);
                        });
                    }
                } catch (error) {
                    this.log(`    Audio element check error: ${error.message}`);
                }
            }
            
            analyzeAudioStream(stream) {
                try {
                    const AudioContextClass = window.AudioContext || window.webkitAudioContext;
                    const audioContext = new AudioContextClass();
                    
                    // Create analyser to check if audio data is flowing
                    const analyser = audioContext.createAnalyser();
                    const source = audioContext.createMediaStreamSource(stream);
                    source.connect(analyser);
                    
                    analyser.fftSize = 256;
                    const bufferLength = analyser.frequencyBinCount;
                    const dataArray = new Uint8Array(bufferLength);
                    
                    this.log(`    ðŸ”¬ Analyzing bot audio stream...`);
                    
                    // Check for audio activity
                    let checkCount = 0;
                    const maxChecks = 10;
                    
                    const checkAudioData = () => {
                        analyser.getByteFrequencyData(dataArray);
                        
                        // Calculate average audio level
                        let sum = 0;
                        for (let i = 0; i < bufferLength; i++) {
                            sum += dataArray[i];
                        }
                        const average = sum / bufferLength;
                        
                        this.log(`    ðŸ“Š Audio level check ${checkCount + 1}: average=${average.toFixed(2)}, max=${Math.max(...dataArray)}`);
                        
                        if (average > 1) {
                            this.log(`    ðŸŽ‰ AUDIO DATA DETECTED! The bot is producing sound.`);
                            // Try to route this analyzed stream directly to speakers
                            source.connect(audioContext.destination);
                            this.log(`    ðŸ”§ Connected audio stream directly to speakers`);
                        } else if (checkCount === maxChecks - 1) {
                            this.log(`    ðŸ˜• No audio data detected after ${maxChecks} checks. Bot may not be producing audio.`);
                        }
                        
                        checkCount++;
                        if (checkCount < maxChecks) {
                            setTimeout(checkAudioData, 500);
                        }
                    };
                    
                    setTimeout(checkAudioData, 500);
                    
                } catch (error) {
                    this.log(`    Audio stream analysis error: ${error.message}`);
                }
            }
            
            showError(message) {
                this.errorDiv.textContent = message;
                this.errorDiv.style.display = 'block';
                setTimeout(() => {
                    this.errorDiv.style.display = 'none';
                }, 5000);
            }
            
            updateStatus(status, className) {
                this.statusDiv.textContent = status;
                this.statusDiv.className = `status ${className}`;
            }
            
            updateButtonStates() {
                this.connectBtn.disabled = this.isConnected;
                this.disconnectBtn.disabled = !this.isConnected;
                this.toggleMicBtn.disabled = !this.isConnected;
                this.debugAudioBtn.disabled = !this.isConnected;
            }
            
            async connect() {
                try {
                    this.updateStatus('Connecting...', 'connecting');
                    this.log('Attempting to connect to bot...');
                    
                    const serverUrl = this.serverUrlInput.value;
                    const botType = this.botTypeSelect.value;
                    const enableMic = this.enableMicCheck.checked;
                    
                    // Create the transport (audio-only)
                    const transport = new DailyTransport({
                        bufferLocalAudioUntilBotReady: true,
                        inputSettings: {
                            audio: {
                                processor: {
                                    type: 'noise-cancellation'
                                }
                            }
                        }
                    });
                    
                    // Create the client (audio-only)
                    this.client = new PipecatClient({
                        transport: transport,
                        enableCam: false,
                        enableMic: enableMic,
                        callbacks: {
                            onConnected: () => {
                                this.isConnected = true;
                                this.updateStatus('Connected', 'connected');
                                this.updateButtonStates();
                                this.log('Successfully connected to bot');
                                this.updateMicStatus(enableMic);
                            },
                            onDisconnected: () => {
                                this.isConnected = false;
                                this.updateStatus('Disconnected', 'disconnected');
                                this.updateButtonStates();
                                this.updateMicStatus(false);
                                this.log('Disconnected from bot');
                            },
                            onError: (error) => {
                                this.log(`Error: ${error.message || error}`);
                                this.showError(`Connection error: ${error.message || error}`);
                            },
                            onBotReady: () => {
                                this.log('Bot is ready to interact');
                                // Check audio setup
                                this.debugAudioSetup();
                            },
                            onBotStartedSpeaking: () => {
                                this.log('Bot started speaking');
                            },
                            onBotStoppedSpeaking: () => {
                                this.log('Bot stopped speaking');
                            },
                            onUserStartedSpeaking: () => {
                                this.log('User started speaking');
                                this.updateMicStatus(true);
                            },
                            onUserStoppedSpeaking: () => {
                                this.log('User stopped speaking');
                                this.updateMicStatus(this.enableMicCheck.checked);
                            },
                            onTrackStarted: (track, participant) => {
                                this.log(`Track started: ${track.kind} from ${participant?.user_name || participant?.user_id || 'unknown'}`);
                                if (track.kind === 'audio') {
                                    this.log('Bot audio track detected - checking if playing...');
                                    setTimeout(() => this.debugAudioSetup(), 1000);
                                }
                            },
                            onTrackStopped: (track, participant) => {
                                this.log(`Track stopped: ${track.kind} from ${participant?.user_name || participant?.user_id || 'unknown'}`);
                            }
                        }
                    });
                    
                    // Connect to the server
                    const endpoint = `${serverUrl}/connect/${botType}`;
                    this.log(`Connecting to endpoint: ${endpoint}`);
                    
                    await this.client.connect({ endpoint });
                    
                } catch (error) {
                    this.log(`Connection failed: ${error.message}`);
                    this.showError(`Failed to connect: ${error.message}`);
                    this.updateStatus('Connection Failed', 'disconnected');
                    this.updateButtonStates();
                }
            }
            
            async disconnect() {
                try {
                    this.log('Disconnecting from bot...');
                    if (this.client) {
                        await this.client.disconnect();
                        this.client = null;
                    }
                    this.isConnected = false;
                    this.updateStatus('Disconnected', 'disconnected');
                    this.updateButtonStates();
                    this.updateMicStatus(false);
                    this.log('Disconnected successfully');
                } catch (error) {
                    this.log(`Disconnect error: ${error.message}`);
                    this.showError(`Disconnect error: ${error.message}`);
                }
            }
            
            async toggleMicrophone() {
                if (this.client) {
                    try {
                        await this.client.toggleMic();
                        this.log('Microphone toggled');
                        this.updateMicStatus(this.enableMicCheck.checked);
                    } catch (error) {
                        this.log(`Error toggling microphone: ${error.message}`);
                        this.showError(`Error toggling microphone: ${error.message}`);
                    }
                }
            }
        }
        
        // Initialize the bot client when the page loads
        window.addEventListener('DOMContentLoaded', () => {
            new PipecatBotClient();
        });
    </script>
</body>
</html> 